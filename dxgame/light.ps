// Filename: light.ps

// globals:
Texture2D shaderTexture[15] : register(t0);
SamplerState SampleType;

// this buffer needs to be split up into separate lights and material buffers:
cbuffer LightBuffer
{
	float4 ambientColor;
	float4 diffuseColor;
    float4 specularColor;
    float3 lightDirection;
    float specularPower;
	float time;            // this isn't strictly light but it's useful for goofy effects
	float3 cameraPos;
};
// end of globals

struct PixelInputType
{
    float4 position : SV_POSITION;
	float4 modelPos : MODELPOS;
	float4 worldPos : WORLDPOS;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
	float3 viewDirection : VIEWDIR;
	nointerpolation uint texNum : TEXINDEX;                    // which texture to use
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	float3 lightDir;
	float lightIntensity;
	float4 color;
    float4 specular;
	uint texNum = input.texNum;

	if (texNum == 0)
	{
		textureColor = shaderTexture[0].Sample(SampleType, input.tex);
	} else if (texNum == 1)
	{
		textureColor = shaderTexture[1].Sample(SampleType, input.tex);
	} else if (texNum == 2)
	{
		textureColor = shaderTexture[2].Sample(SampleType, input.tex);
	} else if (texNum == 3)
	{
		textureColor = shaderTexture[3].Sample(SampleType, input.tex);
	} else if (texNum == 4)
	{
		textureColor = shaderTexture[4].Sample(SampleType, input.tex);
	} else if (texNum == 5)
	{
		textureColor = shaderTexture[5].Sample(SampleType, input.tex);
	} else if (texNum == 6)
	{
		textureColor = shaderTexture[6].Sample(SampleType, input.tex);
	} else if (texNum == 7)
	{
		textureColor = shaderTexture[7].Sample(SampleType, input.tex);
	} else if (texNum == 8)
	{
		textureColor = shaderTexture[8].Sample(SampleType, input.tex);
	}
	// Set the default output color to the ambient light value for all pixels.
    color = ambientColor;

	// Initialize the specular color.
	specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    lightIntensity = saturate(dot(input.normal, lightDir));

	if(lightIntensity > 0.0f)
    {
        // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += (diffuseColor * lightIntensity);

	    // Saturate the ambient and diffuse color.
		color = saturate(color);

		float3 viewDirection = normalize(cameraPos - input.worldPos.xyz);

		//a graphical representation of the slight difference between the results of interpolating view direction and interpolating world position for recalculating view direction
		//float3 r = 400 * abs(viewDirection - input.viewDirection);
		//float3 r = abs(input.normal);
		//float4 rr = {r.x, r.y, r.z, 1.0f};
		//return rr;

		// calculate half-vector for Blinn-Phong specular model
		float3 H = normalize(-lightDirection + viewDirection);
		specular = specularColor * pow(saturate(dot(H, normalize(input.normal))), specularPower);

		// Determine the amount of specular light based on the reflection vector, viewing direction, and specular power.
        //specular = pow(saturate(dot(reflection, input.viewDirection)), specularPower);
    }

    // Multiply the texture pixel and the input color to get the textured result.
    color = color * textureColor;

	// Add the specular component last to the output color.
    color = saturate(color + specular);

    return color;
}