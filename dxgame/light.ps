// Filename: light.ps

// globals:
Texture2D diffuseTexture[15] : register(t0);
Texture2D normalMap : register(t1);
SamplerState SampleType;

// this buffer needs to be split up into separate lights and material buffers:
cbuffer MaterialBuffer : register(b0)
{
	float4 ambientColor;
	float4 diffuseColor;
    float4 specularColor;
    float specularPower;
	bool useNormalMap;
	float2 padding;
}

#define NUM_SPOTLIGHTS 4

cbuffer LightBuffer : register(b1)
{
    float3 lightDirection; // directional light; one is enough for now?
	float time;            // this isn't strictly light but it's useful for goofy effects
	float4 cameraPos;
	float4 spotlightPos[NUM_SPOTLIGHTS];  // spotlights!
	float4 spotlightDir[NUM_SPOTLIGHTS];  // float3 would take up 4 floats anyway, might as well make it explicit
	float4 spotlightEtc[NUM_SPOTLIGHTS];  // arrays are packed into 4-float elements anyway so this is {Cos(angle), constant attenuation, linear, quadratic}
};
// end of globals

struct PixelInputType
{
    float4 position : SV_POSITION;
	float4 modelPos : MODELPOS;
	float4 worldPos : WORLDPOS;
    float2 tex : TEXCOORD0;
	nointerpolation uint texNum : TEXINDEX;                    // which texture to use
	float3 normal : NORMAL;
	float3 tangent : TANGENT;
	float3 viewDirection : VIEWDIR;
};


static const float PI = 3.14159265358979;

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	float3 lightDir;
	float lightIntensity;
	float4 color;
    float4 specular = 0.0f;
	uint texNum = input.texNum;
	float3 tangent = input.tangent;
	//tangent = normalize(input.tangent);

	//return float4(0, dot(input.tangent, input.normal), 0, 1)*10; // uncomment for error visualization
	//return float4(tangent.x, tangent.y, tangent.z, 1); // uncomment for amazing technicolor vomit shader

	textureColor = diffuseTexture[0].Sample(SampleType, input.tex);

#if 0
	// XXX this is only used by ComplexMesh which sends multiple disparate meshes as one draw call
	// diffuseTexture[texNum] doesn't compil so this was the best I could come up with
	// anyway, it's not actually being used by anything in practice now
	// CompoundMesh sends meshes separately
	if (texNum == 0)
	{
		textureColor = diffuseTexture[0].Sample(SampleType, input.tex);
	} else if (texNum == 1)
	{
		textureColor = diffuseTexture[1].Sample(SampleType, input.tex);
	} else if (texNum == 2)
	{
		textureColor = diffuseTexture[2].Sample(SampleType, input.tex);
	} else if (texNum == 3)
	{
		textureColor = diffuseTexture[3].Sample(SampleType, input.tex);
	} else if (texNum == 4)
	{
		textureColor = diffuseTexture[4].Sample(SampleType, input.tex);
	} else if (texNum == 5)
	{
		textureColor = diffuseTexture[5].Sample(SampleType, input.tex);
	} else if (texNum == 6)
	{
		textureColor = diffuseTexture[6].Sample(SampleType, input.tex);
	} else if (texNum == 7)
	{
		textureColor = diffuseTexture[7].Sample(SampleType, input.tex);
	} else if (texNum == 8)
	{
		textureColor = diffuseTexture[8].Sample(SampleType, input.tex);
	}
	// end nonsense
#endif

	if (textureColor.a < 0.05f)
	{
		clip(-1); // discard transparent pixels
		return float4(1.0f, 0.1f, 0.1f, 1.0f); // if discard doesn't work, pixels will show up red; N.B., it works
	}

	float3 normal;

	// make sure tangent is orthonormal (to normal)
	// essentially subtracts any component of tangent along the direction of the normal [Luna, figure 18.6]
	if (useNormalMap)
	{
		//normal = normalize(input.normal);
		//tangent = normalize(input.tangent);
		tangent = tangent - input.normal * dot(tangent, input.normal);
		float3 binormal = normalize(cross(input.normal, tangent));
		float3x3 tangentToWorld = float3x3(tangent, binormal, input.normal);

		float3 mapped_normal = normalMap.Sample(SampleType, input.tex).xyz*2 - float3(1,1,1); // rescale the values to [-1,+1] range
		//return mapped_normal;
	
		normal = normalize(mul(mapped_normal, tangentToWorld));
	} else
	{
		normal = normalize(input.normal);
	}

	// vector from the eye
	float3 viewDirection = normalize(cameraPos.xyz - input.worldPos.xyz );

	// Set the default output color to the ambient light value for all pixels.
    color = ambientColor;

	// Initialize the specular color.
	specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    lightIntensity = saturate(dot(normal, lightDir));

	if(lightIntensity > 0.0f)
    {
        // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += (diffuseColor * lightIntensity);

	    // Saturate the ambient and diffuse color.
		color = saturate(color);

		//a graphical representation of the slight difference between the results of interpolating view direction and interpolating world position for recalculating view direction
		//float3 r = abs(normalize(viewDirection) - input.viewDirection); // actually, this seems broken right now
		//float3 r = abs(normal);
		//float4 rr = {r.x, r.y, r.z, 1.0f};
		//return rr;

		// calculate half-vector for Blinn-Phong specular model
		float3 H = normalize(-lightDirection + viewDirection);
		// calculate specular reflection based on dot product of half-vector and normal vector, along with material data
		specular = specularColor * pow(saturate(dot(H, normal)), specularPower);
    }

	// spotlight calculations
	for (uint i = 0; i < NUM_SPOTLIGHTS; ++i) // once per light...
	{
		if (spotlightPos[i].w == 0.0) break; // out of lights in the scene
		
		float3 sourceToPixel = input.worldPos.xyz - spotlightPos[i].xyz;
		float distToLight = distance(input.worldPos, spotlightPos[i]);
		sourceToPixel = sourceToPixel / distToLight; // not sure whether the HLSL compiler will optimize distance(), normalize() like so; TODO: check asm output? :/

		float beamAlignment = dot(spotlightDir[i], sourceToPixel);
		float beamCosAngle = spotlightEtc[i].x;

		if (beamAlignment > 0.0 && beamAlignment > beamCosAngle)
		{
			float3 toLight = -sourceToPixel;
			float spotlightIntensity = dot(normal, toLight);

			if (spotlightIntensity > 0.0)
			{
				float attenuation = 1.0 / (spotlightEtc[i].y + spotlightEtc[i].z * distToLight + spotlightEtc[i].w * pow(distToLight,2));

				//return float4(0,1,0,1); // horrid green spotlight debugging

				//beamAlignment = pow(beamAlignment,100); // XXX this seems like stupid way of doing this but the books do it pretty much like this, it turns out

				//float fallOff = saturate((beamAlignment*1.00001-beamCosAngle)/(1-beamCosAngle)); // maybe this way is stupid too; 1.0001 was chosen experimentally
				float fallOff = sin(PI/1.3 * (beamAlignment-beamCosAngle)/(1-beamCosAngle)); // maybe this way is stupid too; 1.0001 was chosen experimentally
				
				spotlightIntensity *= fallOff * diffuseColor * attenuation; 

				color = color + spotlightIntensity;

				// calculate half-vector for Blinn-Phong specular model
				float3 H = normalize(toLight + viewDirection);
				// calculate specular reflection based on dot product of half-vector and normal vector, along with material data
				specular += fallOff * specularColor * pow(saturate(dot(H, normalize(normal))), specularPower);
			}
		}
	}

    // Multiply the texture pixel and the input color to get the textured result.
    color = color * textureColor;

	// Add the specular component last to the output color.
    color = saturate(color + specular);

    return color;
}