// Filename: light.ps

// globals:
Texture2D shaderTexture[15] : register(t0);
SamplerState SampleType;

// this buffer needs to be split up into separate lights and material buffers:
cbuffer MaterialBuffer : register(b0)
{
	float4 ambientColor;
	float4 diffuseColor;
    float4 specularColor;
    float specularPower;
	float3 padding;
}

#define NUM_SPOTLIGHTS 4

cbuffer LightBuffer : register(b1)
{
    float3 lightDirection; // directional light; one is enough for now?
	float time;            // this isn't strictly light but it's useful for goofy effects
	float4 cameraPos;
	float4 spotlightPos[NUM_SPOTLIGHTS];  // spotlights!
	float3 spotlightDir[NUM_SPOTLIGHTS]; 
	float spotlightBeamAngle[NUM_SPOTLIGHTS]; // dir + angle = 4 floats so buffer size should be OK
};
// end of globals

struct PixelInputType
{
    float4 position : SV_POSITION;
	float4 modelPos : MODELPOS;
	float4 worldPos : WORLDPOS;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
	float3 viewDirection : VIEWDIR;
	nointerpolation uint texNum : TEXINDEX;                    // which texture to use
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	float3 lightDir;
	float lightIntensity;
	float4 color;
    float4 specular;
	uint texNum = input.texNum;

	// XXX this is only used by ComplexMesh which sends multiple disparate meshes as one draw call
	// shaderTexture[texNum] doesn't compil so this was the best I could come up with
	// anyway, it's not actually being used by anything in practice now
	// CompoundMesh sends meshes separately
	if (texNum == 0)
	{
		textureColor = shaderTexture[0].Sample(SampleType, input.tex);
	} else if (texNum == 1)
	{
		textureColor = shaderTexture[1].Sample(SampleType, input.tex);
	} else if (texNum == 2)
	{
		textureColor = shaderTexture[2].Sample(SampleType, input.tex);
	} else if (texNum == 3)
	{
		textureColor = shaderTexture[3].Sample(SampleType, input.tex);
	} else if (texNum == 4)
	{
		textureColor = shaderTexture[4].Sample(SampleType, input.tex);
	} else if (texNum == 5)
	{
		textureColor = shaderTexture[5].Sample(SampleType, input.tex);
	} else if (texNum == 6)
	{
		textureColor = shaderTexture[6].Sample(SampleType, input.tex);
	} else if (texNum == 7)
	{
		textureColor = shaderTexture[7].Sample(SampleType, input.tex);
	} else if (texNum == 8)
	{
		textureColor = shaderTexture[8].Sample(SampleType, input.tex);
	}
	// end nonsense

	if (textureColor.a < 0.05f)
	{
		clip(-1); // discard transparent pixels
		return float4(1.0f, 0.1f, 0.1f, 1.0f); // if discard doesn't work, pixels will show up red
	}

	// Set the default output color to the ambient light value for all pixels.
    color = ambientColor;

	// Initialize the specular color.
	specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    lightIntensity = saturate(dot(input.normal, lightDir));

	if(lightIntensity > 0.0f)
    {
        // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += (diffuseColor * lightIntensity);

	    // Saturate the ambient and diffuse color.
		color = saturate(color);

		float3 viewDirection = normalize(cameraPos.xyz - input.worldPos.xyz);

		//a graphical representation of the slight difference between the results of interpolating view direction and interpolating world position for recalculating view direction
		//float3 r = abs(normalize(viewDirection) - input.viewDirection); // actually, this seems broken right now
		//float3 r = abs(input.normal);
		//float4 rr = {r.x, r.y, r.z, 1.0f};
		//return rr;

		// calculate half-vector for Blinn-Phong specular model
		float3 H = normalize(-lightDirection + viewDirection);
		// calculate specular reflection based on dot product of half-vector and normal vector, along with material data
		specular = specularColor * pow(saturate(dot(H, normalize(input.normal))), specularPower);
    }

	// spotlight calculations
	//return float4(0, distance(input.worldPos, cameraPos), sin(time*10), 1);

	float3 sourceToPixel = normalize(input.worldPos.xyz - spotlightPos[0].xyz);
	float beamAlignment = dot(spotlightDir[0], sourceToPixel);

	if (beamAlignment > 0.0 && beamAlignment > cos(3.14159268358979/16))
	{
		float3 toLight = -sourceToPixel;
		float spotlightIntensity = dot(input.normal, toLight);
		if (spotlightIntensity > 0.0)
		{
			spotlightIntensity *= beamAlignment * diffuseColor; // TODO proper falloff
			// TODO distance-based attenuation

			color = saturate(color + spotlightIntensity);
		}
	}

    // Multiply the texture pixel and the input color to get the textured result.
    color = color * textureColor;

	// Add the specular component last to the output color.
    color = saturate(color + specular);

    return color;
}