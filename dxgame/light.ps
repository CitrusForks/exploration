// Filename: light.ps

// globals:
Texture2D shaderTexture[15] : register(t0);
SamplerState SampleType;

// this buffer needs to be split up into separate lights and material buffers:
cbuffer MaterialBuffer : register(b0)
{
	float4 ambientColor;
	float4 diffuseColor;
    float4 specularColor;
    float specularPower;
	float3 padding;
}

#define NUM_SPOTLIGHTS 4

cbuffer LightBuffer : register(b1)
{
    float3 lightDirection; // directional light; one is enough for now?
	float time;            // this isn't strictly light but it's useful for goofy effects
	float4 cameraPos;
	float4 spotlightPos[NUM_SPOTLIGHTS];  // spotlights!
	float4 spotlightDir[NUM_SPOTLIGHTS];  // need the fourth float for packing alignment :|
	float spotlightBeamCosAngle[NUM_SPOTLIGHTS];
};
// end of globals

struct PixelInputType
{
    float4 position : SV_POSITION;
	float4 modelPos : MODELPOS;
	float4 worldPos : WORLDPOS;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
	float3 viewDirection : VIEWDIR;
	nointerpolation uint texNum : TEXINDEX;                    // which texture to use
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	float3 lightDir;
	float lightIntensity;
	float4 color;
    float4 specular = 0.0f;
	uint texNum = input.texNum;

	// XXX this is only used by ComplexMesh which sends multiple disparate meshes as one draw call
	// shaderTexture[texNum] doesn't compil so this was the best I could come up with
	// anyway, it's not actually being used by anything in practice now
	// CompoundMesh sends meshes separately
	if (texNum == 0)
	{
		textureColor = shaderTexture[0].Sample(SampleType, input.tex);
	} else if (texNum == 1)
	{
		textureColor = shaderTexture[1].Sample(SampleType, input.tex);
	} else if (texNum == 2)
	{
		textureColor = shaderTexture[2].Sample(SampleType, input.tex);
	} else if (texNum == 3)
	{
		textureColor = shaderTexture[3].Sample(SampleType, input.tex);
	} else if (texNum == 4)
	{
		textureColor = shaderTexture[4].Sample(SampleType, input.tex);
	} else if (texNum == 5)
	{
		textureColor = shaderTexture[5].Sample(SampleType, input.tex);
	} else if (texNum == 6)
	{
		textureColor = shaderTexture[6].Sample(SampleType, input.tex);
	} else if (texNum == 7)
	{
		textureColor = shaderTexture[7].Sample(SampleType, input.tex);
	} else if (texNum == 8)
	{
		textureColor = shaderTexture[8].Sample(SampleType, input.tex);
	}
	// end nonsense

	if (textureColor.a < 0.05f)
	{
		clip(-1); // discard transparent pixels
		return float4(1.0f, 0.1f, 0.1f, 1.0f); // if discard doesn't work, pixels will show up red
	}

	// vector from the eye
	float3 viewDirection = normalize(cameraPos.xyz - input.worldPos.xyz );

	// Set the default output color to the ambient light value for all pixels.
    color = ambientColor;

	// Initialize the specular color.
	specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    lightIntensity = saturate(dot(input.normal, lightDir));

	if(lightIntensity > 0.0f)
    {
        // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += (diffuseColor * lightIntensity);

	    // Saturate the ambient and diffuse color.
		color = saturate(color);

		//a graphical representation of the slight difference between the results of interpolating view direction and interpolating world position for recalculating view direction
		//float3 r = abs(normalize(viewDirection) - input.viewDirection); // actually, this seems broken right now
		//float3 r = abs(input.normal);
		//float4 rr = {r.x, r.y, r.z, 1.0f};
		//return rr;

		// calculate half-vector for Blinn-Phong specular model
		float3 H = normalize(-lightDirection + viewDirection);
		// calculate specular reflection based on dot product of half-vector and normal vector, along with material data
		specular = specularColor * pow(saturate(dot(H, normalize(input.normal))), specularPower);
    }

	// spotlight calculations
	for (uint i = 0; i < NUM_SPOTLIGHTS; ++i) // once per light...
	{
		if (spotlightPos[i].w == 0.0) break; // out of lights in the scene
		float3 sourceToPixel = normalize(input.worldPos.xyz - spotlightPos[i].xyz);
		float beamAlignment = dot(spotlightDir[i], sourceToPixel);

		if (beamAlignment > 0.0 && beamAlignment > spotlightBeamCosAngle[i])
		{
			float3 toLight = -sourceToPixel;
			float spotlightIntensity = dot(input.normal, toLight);
			if (spotlightIntensity > 0.0)
			{
				beamAlignment = pow(beamAlignment,100); // XXX this is a stupid way of doing this
				spotlightIntensity *= beamAlignment * diffuseColor; // TODO proper falloff
				// TODO distance-based attenuation

				color = saturate(color + spotlightIntensity);

				// calculate half-vector for Blinn-Phong specular model
				float3 H = normalize(toLight + viewDirection);
				// calculate specular reflection based on dot product of half-vector and normal vector, along with material data
				specular += beamAlignment * specularColor * pow(saturate(dot(H, normalize(input.normal))), specularPower);
			}
		}
	}

    // Multiply the texture pixel and the input color to get the textured result.
    color = color * textureColor;

	// Add the specular component last to the output color.
    color = saturate(color + specular);

    return color;
}